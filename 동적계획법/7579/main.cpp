#include <iostream>

using namespace std;

int dp[10001] = {0};

int main()
{
    int n,M;
    int sum = 0;
    cin >> n >> M;
    int m[101];
    int c[101];
    for(int i=1; i<=n; i++){
        cin >> m[i];
    }
    for(int i=1; i<=n; i++){
        cin >> c[i];
        sum += c[i];
    }
    dp[0] = 0;
    for(int i=1; i<=n; i++){
        for(int j=sum; j>=c[i]; j--){
            if(dp[j] < dp[j-c[i]] + m[i]) dp[j] = dp[j-c[i]] + m[i];
        }
    }
    for(int i=1; i<=sum; i++){
        if(dp[i] >= M){
            cout << i;
            break;
        }
    }
}
/*

앱의 비활성화를 위해서는 앱을 몇개 종료해야하고 이때 비용의 최소값을 알고 싶은 문제이다.

냅색문제랑은 조건이 정반대이다.

먼저 생각해본건 m1+m2+...+m_n - M을 만드는 최대 비용을 구하는 것이다.

예를 들어
메모리 30 10 20 35 40
  비용 3  0  3  5  4

이면

75를 최대 비용으로 만들수있는 경우 비용이 9가 되어 답은 15 - 9 = 6이다.
그렇지만 범위랑 조건이 매우 커져 안될것이다.

반대로 그럼 어떤 비용일때 가능한 최대 메모리를 구하면
  비용  1  2  3  4  5  6  7  8   9  10  11  12
메모리 10 10 40 50 50 60 80 80  95 100 115 115

즉 비용 6으로는 최대 60의 메모리를 가질 수 있다.
이는 반대로 생각하면 60의 메모리를 가지려면 최소 6의 비용이 필요하다는 말과 같다.

그럼 82의 메모리를 가지려면? 최소 9의 비용이 필요하다. 비용 8으로는 최대 80까지만 가능하기 때문이다.

*/
























