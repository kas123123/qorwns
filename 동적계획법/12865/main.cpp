#include <iostream>

using namespace std;

int val[100001]={0};
int mx=0;

int main()
{
    int n,k,x,v;
    cin >> n >> k;
    for(int i=0; i<n; i++){
        cin >> x >> v;
        for(int j=k-x; j>=0; j--){
            if(val[j] + v > val[j+x]) {
                val[j+x] = val[j] + v;
                if(val[j+x] > mx) mx = val[j+x];
            }
        }
    }
    cout << mx;
}

/*
1.

dp[i][j] = i번째까지 진행했을때 배낭용량이 j이고 이때 들어간 물건의 가치 최대 값이라하자.

이 값의 경우는 2가지로 나뉜다.

1) i번째 물건이 들어가지 않았다.
이 경우는 i번째 물건을 포함하지 않고 용량 j일때 가치가 최대인 경우이다.
    dp[i][j] = dp[i-1][j]

2) i번째 물건이 들어갔다.
이 경우는 i번째 물건을 포함해야 용량 j일때 가치가 최대인 경우이다.
    dp[i][j] = dp[i-1][j-(i번째의 용량)] + (i번째의 가치)

이 두 경우 중 큰 값을 선택하면 된다.

2.

dp[i] = 용량이 j일때 가능한 가치의 최대값이라 하자.

dp[1] = 0 dp[2] = 0 dp[3] = 0 dp[4] = 0 dp[5] = 0
처음에는 다 0 이다.

이때 용량이 3이고 가치가 4인 1번 물건이 들어간다고 하자.

용량이 큰것부터 생각할때 4 + dp[2] > 0 이므로 dp[5] = 4가된다.

dp[1] = 0 dp[2] = 0 dp[3] = 4 dp[4] = 4 dp[5] = 4

다시 용량이 1이고 가치가 1인 물건이 들어간다고 하자.

dp[4] + 1(가치가 1인 물건) > 4 이므로 dp[5] = 5가 된다.

dp[1] = 1 dp[2] = 1 dp[3] = 4 dp[4] = 5 dp[5] = 5

반복하면 됨.

*/
